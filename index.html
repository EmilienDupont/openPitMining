<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>
@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}

text {
  font-family: sans-serif
}

rect:hover {
  opacity: .8;
}

.typea {
  fill: gray;
  color: gray;
}

.typeb {
  fill: silver;
  color: silver;
}

.typec {
  fill: brown;
  color: brown;
}

.typed {
  fill: gold;
  color: gold;
}

.typee {
  fill: purple;
  color: purple;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Open Pit Mining</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>
    <p>
      In this example we'll solve a simple mining problem: how to extract rock or minerals from an open pit while incurring the smallest cost.
    </p>
    <p>
    We'll construct a mathematical model of the business problem, implement this model in Gurobi's Python interface, and compute and visualize an optimal solution.
    </p>
    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      <p>
        <a href="http://www.tulane.edu/~sanelson/eens1110/minresources.htm"> Measurements of gravity, magnetism and radioactivity</a> have determined a location to be rich in a metal ore
        and appropriate for open pit mining. The open pit mine has been divided into several blocks and we now need to decide which blocks
        to extract and which to leave.
        <div style="float: right;">
          <img src="openPitMine.jpg" alt="Open Pit Mine" style="width:302px;height:228px;">
          <p> <a href="http://www.mine-engineer.com/mining/open_pit.htm"> Mine-engineer </a> defines an open pit mine as: "an excavation or cut made at the surface
          of the ground for the purpose of extracting ore and which is open to the surface for the duration of the mine's life."
          (<a href="http://www.mining-technology.com/contractors/project/marston/marston4.html"> Image Source </a>) </p>
        </div>
      </p>

      <p>
        The concentration of ore in each of the blocks has been determined through test drilling. This concentration and the market value of the ore
        allows us to determine the profit gained from extracting each block.
      </p>
      <p> However, there is also a cost related to extracting the block from the ground. Usually, the deeper the rock lies the more expensive it is
      to remove. In addition we cannot remove the rocks in an arbitrary order: to remove any block we must also remove the block above it. We also need
      trucks to enter the mine and remove the ore, so we have restrictions on the slope of the mine: to remove a block, the blocks above and to the left
      and above and to the right must also be removed.</p>
      <p>
        Given these restrictions, we will use Gurobi to compute the order in which to extract the blocks to maximize profit.
      </p>
    </div>


    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>
      <p> Let us now formulate a <a href="http://liu.diva-portal.org/smash/get/diva2:442025/FULLTEXT01.pdf"> Mathematical Model </a>
      for the problem. </p>

      <p> The ground has been separated into several blocks, each of which has a known concentration of the metal ore. With each of these
      blocks we associate a binary variable $x_i$ such that if $x_i = 1$ we extract the block, otherwise we don't. </p>

      <p>
      We denote by $v_i$ the value of block $i$ which is proportional to the concentration of the metal ore. </p>


      <p>The blocks are distributed on several levels (level 1 corresponds to the surface, level 2 to the level immediately below it etc...).
      The deeper the blocks lie, the more costly they are to remove.
      Therefore, we also associate a cost $c_i$ with each block, which corresponds to the cost of removing it from the earth.</p>

      <div id="blockdemo">
      </div>
      <p> Fig. 1: Hover over the different blocks to see which blocks need to be removed. </p>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        var width = 600,
            height = 250,
            size = width/6;

        var svgdemo = d3.select("#blockdemo").append("svg")
                    .attr("width", width)
                    .attr("height", height);

        var backgroundG = svgdemo.append("g");

        var blocksG = svgdemo.append("g");

        backgroundG.append("rect").attr("x", 0).attr("y", 0)
                   .attr("height", height).attr("width", width)
                   .attr("fill", "#eaf1ea");

        var blockdata = [];

        for (var i = 0; i < 6; i++) {
          if (i < 4) {
            blockdata.push([(i+1)*size, (height - 2*size)/2]);
          } else {
            blockdata.push([(i-2)*size, height/2]);
          }
        }

        var blocks = blocksG.selectAll("rect")
                            .data(blockdata)
                            .enter()
                            .append("rect")
                            .attr("x", function(d) { return d[0]; })
                            .attr("y", function(d) { return d[1]; })
                            .attr("id", function(d,i) { return "blockdemo" + String(i); })
                            .attr("width", size)
                            .attr("height", size)
                            .attr("stroke", "black")
                            .attr("fill", "#cdc")
                            .on("mouseover", blockhover)
                            .on("mouseout", blockstop);

        var texts = svgdemo.selectAll("text")
                           .data(blockdata)
                           .enter()
                           .append("text")
                           .text(function(d,i) { return String(i+1); })
                           .attr("x", function(d) { return d[0] + size/2; })
                           .attr("y", function(d) { return d[1] + size/2; })
                           .attr("font-family", "sans-serif")
                           .attr("font-size", "18px")
                           .attr("fill", "white")
                           .attr("font-weight", 800)
                           .attr("text-anchor", "middle");


        svgdemo.append("line")
               .attr("x1", 0)
               .attr("x2", width)
               .attr("y1", (height - 2*size)/2)
               .attr("y2", (height - 2*size)/2)
               .attr("stroke", "black")
               .attr("stroke-width", 2);

        function blockhover() {
          var id = d3.select(this).attr("id").slice(-1);
          id = parseInt(id);
          if (id < 4) {
            d3.select(this).attr("fill", "#a3b0a3");
          }
          if (id === 4 ) {
            d3.select("#blockdemo0").attr("fill", "#a3b0a3");
            d3.select("#blockdemo1").attr("fill", "#a3b0a3");
            d3.select("#blockdemo2").attr("fill", "#a3b0a3");
            d3.select(this).attr("fill", "#a3b0a3");
          }
          if (id === 5) {
            d3.select("#blockdemo1").attr("fill", "#a3b0a3");
            d3.select("#blockdemo2").attr("fill", "#a3b0a3");
            d3.select("#blockdemo3").attr("fill", "#a3b0a3");
            d3.select(this).attr("fill", "#a3b0a3");
          }
        }

        function blockstop() {
          for (var i = 0; i < blockdata.length; i++ ) {
            var id = "#blockdemo" + String(i);
            d3.select(id).attr("fill", "#cdc");
          }
        }
      </script>

      <p>However, as seen in the <a href="#problem"> Problem Description </a> section, there is a constraint on the order in which the blocks
      can be removed. We can impose these constraints by drawing a precedence graph $G$. We consider the blocks to be the nodes of the graph,
      and we draw a directed edge, from every block $i$ to the block above it, above to the left and above to the right (see Fig. 1). We then have the
      following restriction for each edge $(i,j)$ of the precedence graph
       \[
        x_i \leq x_j \quad \forall (i,j) \, \in G
      \]
      Indeed, if $x_i = 1$ then we must have $x_j = 1$, i.e. if block $i$ is removed then so must the blocks above it. </p>

      <p> Finally, we consider the profit. For each block, the profit is given by $v_i - c_i$ i.e. the value of the ore minus the
      cost to remove the rock. This quantity is of course zero if the block is not removed. So the total profit is given by
      \[
        \text{profit} = \sum_{i} (v_i - c_i)x_i
      \]</p>

      <p> In summary, we wish to
        \[
      \begin{array}{ll}
      \text{maximize} & \sum_{i} (v_i - c_i)x_i \\
      \text{subject to} & x_i \leq x_j \quad \forall (i,j) \, \in G \\
                        & x_i \in \{ 0, 1 \} \, \forall i
      \end{array}
      \]</p>

    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      cost = []; value = []; edges = []; !!! FILL THESE OUT !!!

      m = Model()

      n = len(cost) # number of blocks

      # Indicator variable for each block
      xb = {}
      for i in range(n):
          xb[i] = m.addVar(vtype=GRB.BINARY, name="x%d" % i)

      m.update()

      # Set objective
      m.setObjective(quicksum((value[i] - cost[i])*xb[i] for i in range(n)), GRB.MAXIMIZE)

      # Add constraints
      for edge in edges:
          u = edge[0]
          v = edge[1]
          m.addConstr(xb[u] <= xb[v])

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <p> As an example we consider a mine where 28 blocks on 4 levels have been identified.
      Extraction costs 100,000 USD/block for level 1, 200,000 USD/block for level 2, 300,000 USD/block for level 3 and 500,000 USD/block for level 4.
      The colors of the blocks correspond to different concentrations of ore (and hence different values of the blocks).
      </p>
      <p> You can change the ore concentration of each block by clicking them. You can click the buttons on the top to change
      the type of concentration you want to add.
      Click the Mine away! button to compute the optimal block removing order using Gurobi. To restart, click on any block. </p>
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Mine away!</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>


// Create data for each layer of blocks
var numBlocks = 28
var blocks = [];
for (var i = 0; i < numBlocks; i++) {
  blocks.push(i);
}

var layer2 = 10; var layer3 = 18; var layer4 = 24;

// Different types
var types = ["typea","typeb","typec","typed","typee"];

// Type variable
var type = "typeb";

var width = 700,
    height = 500,
    size = width/(layer2 + 2);

// Create precedence graph
edges = [];

for (var i = layer2; i < layer3; i++) { // range(10,18)
    edges.push([i,i-layer2]);
    edges.push([i,i-layer2+1]);
    edges.push([i,i-layer2+2]);
}

for (var i = layer3; i < layer4; i++) { // range(18,24)
    edges.push([i,i-(layer3-layer2)])
    edges.push([i,i-(layer3-layer2)+1])
    edges.push([i,i-(layer3-layer2)+2])
}

for (var i = layer3; i < numBlocks; i++) { // range(24,28)
    edges.push([i,i-(layer4-layer3)])
    edges.push([i,i-(layer4-layer3)+1])
    edges.push([i,i-(layer4-layer3)+2])
}

// Create cost and value data
cost = [];
value = [];
for (var i = 0; i < numBlocks; i++) {
  if (i >= layer2 && i < layer3) {
    cost.push(200);
  }
  else if (i >= layer3 && i < layer4) {
    cost.push(300);
  }
  else if (i >= layer4) {
    cost.push(500);
  }
  else {
    cost.push(100);
  }
  value.push(0);
}

var profit = 0;

// Start graphics
var svg = d3.select("#demoarea").append("svg")
    .attr("width", width)
    .attr("height", height);

// Create background
var backgroundG = svg.append("g")
    backgroundG.append("polygon").attr("points", "0,233.4, 0,500, 700,500, 700,233.4")
                                 .attr("fill", "rgb(50,50,50)")
                                 .attr("stroke", "black")
                                 .attr("stroke-width", 1);
    backgroundG.append("polygon").attr("points", "0,233.4, 0,0, 700,0, 700,233.4")
                                 .attr("fill", "rgb(6,214,255)");

var buttonsG = svg.append("g");

var buttons = buttonsG.selectAll("circle")
                 .data(types)
                 .enter()
                 .append("circle")
                 .on("mousedown", buttonpress);

    buttons.attr("cx",  function(d,i) {
                          return (i+.5)*size/1.2;
                        })
           .attr("cy", 20)
           .attr("r", 15)
           .attr("class", function(d) { return d;} )
           .attr("stroke", "black")
           .attr("stroke-width", 2);

var labelsG = svg.append("g");

var labels = labelsG.selectAll("text")
                    .data(types)
                    .enter()
                    .append("text")

    labels.attr("x",  function(d,i) {
                          return (i+.5)*size/1.2;
                        })
          .attr("y", 50)
          .text(function (d) { if (d === "typea") {
                                 return "0k$";
                               }
                               else if (d === "typeb") {
                                 return "150k$";
                               }
                               else if (d === "typec") {
                                 return "250k$";
                               }
                               else if (d === "typed") {
                                 return "400k$";
                               }
                               else if (d === "typee") {
                                 return "700k$";
                               }
                               else {
                                 return " ";}
                             });

labelsG.append("text")
       .attr("x", 30)
       .attr("y", 4.5*size)
       .text("100k$");

labelsG.append("text")
       .attr("x", 30 + size)
       .attr("y", 5.5*size)
       .text("200k$");

labelsG.append("text")
       .attr("x", 30 + 2*size)
       .attr("y", 6.5*size)
       .text("300k$");

labelsG.append("text")
       .attr("x", 30 + 3*size)
       .attr("y", 7.5*size)
       .text("500k$");

labelsG.selectAll("text")
       .attr("font-size", "14px")
       .attr("fill", "white")
       .attr("text-anchor", "middle");

var blocksG = svg.append("g");

var blockRect = blocksG.selectAll("rect")
                   .data(blocks)
                   .enter()
                   .append("rect")
                   .on("mousedown", mousedown);

    blockRect.attr("x", function(d) {
              if (d >= layer2 && d < layer3) {
                return (d + 2 - layer2)*size;
              }
              else if (d >= layer3 && d < layer4) {
                return (d + 3 - layer3)*size;
              }
              else if (d >= layer4) {
                return (d + 4 - layer4)*size;
              }
              else {
                return (d+1)*size;
              }
              })
              .attr("y", function(d) {
              if (d >= layer2 && d < layer3) {
                return 5*size;
              }
              else if (d >= layer3 && d < layer4) {
                return 6*size;
              }
              else if (d >= layer4) {
                return 7*size;
              }
              else {
                return 4*size;
              }
              })
              .attr("height", size)
              .attr("width", size)
              .attr("stroke", "black")
              .attr("stroke-width", 1)
              .attr("class", function (d) {
                        var typeinitial;
                        if (d === 0 || d === 6 || d == 9 || d == 11 || d == 16 || d == 17) {
                           typeinitial = "typed";
                        }
                        else if (d === 1 || d === 4 || d == 7 || d == 22 || d == 24) {
                           typeinitial = "typeb";
                        }
                        else if (d === 18 || d === 21 || d == 26 || d == 27) {
                           typeinitial = "typee";
                        }
                        else {
                           typeinitial = "typea";
                        }
                        console.log(typeinitial)
                        return typeinitial;
                    });

var solutionG = svg.append("g");

var solutionRect = solutionG.selectAll("rect")
                  .on("mousedown", removeSol);

// sets type of clicked rectangle
function mousedown() {
  // Remove rectangles from previous solution
  solutionG.selectAll("rect")
           .remove();

  d3.select(this)
    .attr("class", type);
}

// Change the type
function buttonpress() {
  type = d3.select(this).attr("class")
  console.log(type)
}

function removeSol() {
  solutionG.selectAll("rect")
           .remove();
}

// Compute
function compute() {
  //cost = [100, 100, 100, 100, 100, 100, 100, 100, 1000, 200, 200, 200, 200, 1000, 1000, 1000, 300, 1000];
  //value = [200, 0, 0, 0, 0, 0, 300, 0, 0, 500, 0, 200, 0, 0, 0, 0, 1000, 1200];
  blocksG.selectAll("rect").attr("class", function(d) {
                                      var tempType = d3.select(this).attr("class");
                                      if (tempType === "typea") {
                                        value[d] = 0;
                                      }
                                      if (tempType === "typeb") {
                                        value[d] = 150;
                                      }
                                      if (tempType === "typec") {
                                        value[d] = 250;
                                      }
                                      if (tempType === "typed") {
                                        value[d] = 400;
                                      }
                                      if (tempType === "typee") {
                                        value[d] = 700;
                                      }
                                      return d3.select(this).attr("class");
                                    });

  console.log('cost',cost)
  console.log('value',value)
  console.log('edges',edges)

  d3.json('/openPitMining')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'cost': cost,
                          'value': value,
                          'edges': edges }), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          var solTemp = [];
          profit = solution[solution.length - 1]; // Last element is profit

          console.log('test',solution)

          solution = solution.slice(0,solution.length-1);

          console.log('test',solution)

          for (var i = 0; i < solution.length; i++) {
            if (solution[i] === 1) {
              solTemp.push(i);
            }
          }
          solution = solTemp;
          console.log('solution', solution)
          console.log('profit', profit)

          solutionG.selectAll("rect")
                   .remove();

          var rectSol = solutionG.selectAll("rect")
                                   .data(solution)
                                   .enter()
                                   .append("rect");

          rectSol.attr("x", function(d) {
                      if (d >= layer2 && d < layer3) {
                        return (d + 2 - layer2)*size;
                      }
                      else if (d >= layer3 && d < layer4) {
                        return (d + 3 - layer3)*size;
                      }
                      else if (d >= layer4) {
                        return (d + 4 - layer4)*size;
                      }
                      else {
                        return (d+1)*size;
                      }
                      })
                      .attr("y", function(d) {
                      if (d >= layer2 && d < layer3) {
                        return 5*size;
                      }
                      else if (d >= layer3 && d < layer4) {
                        return 6*size;
                      }
                      else if (d >= layer4) {
                        return 7*size;
                      }
                      else {
                        return 4*size;
                      }
                      })
                      .attr("height", size)
                      .attr("width", size)
                      .attr("fill", "rgb(6,214,255)")
                      .attr("stroke", "rgb(6,214,255)")
                      .attr("stroke-width", 1.8)
                      .style("opacity", 0)
                      .style("stroke-opacity", 0)
                      .transition()
                      .style("opacity", 1)
                      .style("stroke-opacity", 1)
                      .duration(500)
                      .delay(function(i) { return i*100 });

          profit = profit/1000;

          solutionG.selectAll("text").remove();

          solutionG.append("text")
                    .text("Profit: " + String(profit) + " million dollars")
                    .attr("x", width/2)
                    .attr("y", 150)
                    .attr("font-size", "22px")
                    .attr("fill", "white")
                    .attr("text-anchor", "middle");


          solutionRect = solutionG.selectAll("rect")
                  .on("mousedown", removeSol);
        }
   }
}

</script>
