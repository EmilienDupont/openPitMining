<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>
@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}


  text {
    font-family: sans-serif
  }

  rect:hover {
    opacity: .8;
  }

  .typea {
    fill: gray;
    color: gray;
  }

  .typeb {
    fill: silver;
    color: silver;
  }

  .typec {
    fill: brown;
    color: brown;
  }

  .typed {
    fill: gold;
    color: gold;
  }

  .typee {
    fill: purple;
    color: purple;
  }


</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Open Pit Mining</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>
    <p>
      In this example we'll solve a simple mining problem: how to extract rock or minerals from an open pit while incurring the smallest cost.
    </p>
    <p>
    We'll construct a mathematical model of the business problem, implement this model in Gurobi's Python interface, and compute and visualize an optimal solution.
    </p>
    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      <p>
        Measurements of gravity, magnetism and radioactivity have determined a location to be rich in a metal ore
        and appropriate for open pit mining. The open pit mine has been divided into several blocks and we now need to decide which blocks
        to extract and which to leave. </p>
      <p> (Add a picture here with a definition of open mine: "an excavation or cut made at the surface of the ground for the purpose of extracting ore
      and which is open to the surface for the duration of the mine's life.") </p>
      <p>
        The concentration of ore in each of the blocks has been determined through test drilling. This concentration and the market value of the ore
        allows us to determine the profit gained from extracting each block.
      </p>
      <p> However, there is also a cost related to extracting the block from the ground. Usually, the deeper the rock lies the more expensive it is
      to remove. In addition we cannot remove the rocks in an arbitrary order: to remove any block we must also remove the block above it. We also need
      trucks to enter the mine and remove the ore, so we have restrictions on the slope of the mine: to remove a block, the blocks above and to the left
      and above and to the right must also be removed.</p>
      <p>
        Given these restrictions, we will use Gurobi to compute the order in which to extract the blocks to maximize profit.
      </p>
      <p> References http://www.tulane.edu/~sanelson/eens1110/minresources.htm http://www.mine-engineer.com/mining/open_pit.htm</p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p> The ground has been separated into several blocks, each of which has a known concentration of the metal ore. With each of these
      blocks we associate a binary variable $x_i$ such that if $x_i = 1$ we extract the block, otherwise we don't. </p>

      <p>
      We denote by $v_i$ the value of block $i$ which is proportional to the concentration of the metal ore. </p>

      <p>The blocks are distributed on several levels (level 1 corresponds to the surface, level 2 to the level immediately below it etc...).
      The deeper the blocks lie, the more costly they are to remove.
      Therefore, we also associate a cost $c_i$ with each block, which corresponds to the cost of removing it from the earth.</p>

      <p>However, there is a constraint on the order in which the blocks can be removed. Indeed, to remove a block from the ground we must
      also remove the block on top of it. Furthermore, due to restrictions on the slope of the mine, the blocks above and to the left and right
      must also be removed. We can impose these constraints by drawing a precedence graph $G$. We consider the blocks to be the nodes of the graph,
      and we draw a directed edge, from every block $i$ to the block above it, above to the left and above to the right. We then have the
      following restriction for each edge $(i,j)$ of the precedence graph
       \[
        x_i \leq x_j \quad \forall (i,j) \, \in G
      \]
      Indeed, if $x_i = 1$ then we must have $x_j = 1$, i.e. if block $i$ is removed then so must the blocks above it. </p>

      <p> Finally, we consider the profit. For each block, the profit is given by $v_i - c_i$ i.e. the value of the ore minus the
      cost to remove the rock. This quantity is of course zero if the block is not removed. So the total profit is given by
      \[
        \text{profit} = \sum_{i} (v_i - c_i)x_i
      \]</p>

      <p> In summary, we wish to
        \[
      \begin{array}{ll}
      \text{maximize} & \sum_{i} (v_i - c_i)x_i \\
      \text{subject to} & x_i \leq x_j \quad \forall (i,j) \, \in G \\
                        & x_i \in \{ 0, 1 \} \, \forall i
      \end{array}
      \]</p>

    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      cost = []; value = []; edges = []; !!! FILL THESE OUT !!!

      m = Model()

      n = len(cost) # number of blocks

      # Indicator variable for each block
      xb = {}
      for i in range(n):
          xb[i] = m.addVar(vtype=GRB.BINARY, name="x%d" % i)

      m.update()

      # Set objective
      m.setObjective(quicksum((value[i] - cost[i])*xb[i] for i in range(n)), GRB.MAXIMIZE)

      # Add constraints
      for edge in edges:
          u = edge[0]
          v = edge[1]
          m.addConstr(xb[u] <= xb[v])

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <p> As an example we consider a mine where 28 blocks on 4 levels have been identified. Each block weighs a 1000 tonnes and
      extraction costs 100USD/tonne for level 1, 200USD/tonne for level 2, 300USD/tonne for level 3 and 500USD/tonne for level 4.
      Each color corresponds to a different concentration of ---some rock type---.
      </p>
      <p> Click the Mine away! button to compute the optimal block removing order using Gurobi. Click on the blocks to change
      the concentration of --some rock type---. You can click on the different circles to change the rock type. </p>
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Mine away!</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>


// Create data for each layer of blocks
var numBlocks = 28
var blocks = [];
for (var i = 0; i < numBlocks; i++) {
  blocks.push(i);
}

var layer2 = 10; var layer3 = 18; var layer4 = 24;

// Different types
var types = ["typea","typeb","typec","typed","typee"];

// Type variable
var type = "typeb";

var width = 700,
    height = 500,
    size = width/(layer2 + 2);

// Create precedence graph
edges = [];

for (var i = layer2; i < layer3; i++) { // range(10,18)
    edges.push([i,i-layer2]);
    edges.push([i,i-layer2+1]);
    edges.push([i,i-layer2+2]);
}

for (var i = layer3; i < layer4; i++) { // range(18,24)
    edges.push([i,i-(layer3-layer2)])
    edges.push([i,i-(layer3-layer2)+1])
    edges.push([i,i-(layer3-layer2)+2])
}

for (var i = layer3; i < numBlocks; i++) { // range(24,28)
    edges.push([i,i-(layer4-layer3)])
    edges.push([i,i-(layer4-layer3)+1])
    edges.push([i,i-(layer4-layer3)+2])
}

// Create cost and value data
cost = [];
value = [];
for (var i = 0; i < numBlocks; i++) {
  if (i >= layer2 && i < layer3) {
    cost.push(200);
  }
  else if (i >= layer3 && i < layer4) {
    cost.push(300);
  }
  else if (i >= layer4) {
    cost.push(500);
  }
  else {
    cost.push(100);
  }
  value.push(0);
}

var profit = 0;

// Start graphics
var svg = d3.select("#demoarea").append("svg")
    .attr("width", width)
    .attr("height", height);

// Create background
var backgroundG = svg.append("g")
    backgroundG.append("polygon").attr("points", "0,233.4, 0,500, 700,500, 700,233.4")
                                 .attr("fill", "rgb(50,50,50)")
                                 .attr("stroke", "black")
                                 .attr("stroke-width", 1);
    backgroundG.append("polygon").attr("points", "0,233.4, 0,0, 700,0, 700,233.4")
                                 .attr("fill", "rgb(6,214,255)");

var buttonsG = svg.append("g");

var buttons = buttonsG.selectAll("circle")
                 .data(types)
                 .enter()
                 .append("circle")
                 .on("mousedown", buttonpress);

    buttons.attr("cx",  function(d,i) {
                          return (i+.5)*size/1.2;
                        })
           .attr("cy", 20)
           .attr("r", 15)
           .attr("class", function(d) { return d;} )
           .attr("stroke", "black")
           .attr("stroke-width", 2);

var labelsG = svg.append("g");

var labels = labelsG.selectAll("text")
                    .data(types)
                    .enter()
                    .append("text")

    labels.attr("x",  function(d,i) {
                          return (i+.5)*size/1.2;
                        })
          .attr("y", 50)
          .text(function (d) { if (d === "typea") {
                                 return "0k$";
                               }
                               else if (d === "typeb") {
                                 return "150k$";
                               }
                               else if (d === "typec") {
                                 return "250k$";
                               }
                               else if (d === "typed") {
                                 return "400k$";
                               }
                               else if (d === "typee") {
                                 return "700k$";
                               }
                               else {
                                 return " ";}
                             });

labelsG.append("text")
       .attr("x", 30)
       .attr("y", 4.5*size)
       .text("100k$");

labelsG.append("text")
       .attr("x", 30 + size)
       .attr("y", 5.5*size)
       .text("200k$");

labelsG.append("text")
       .attr("x", 30 + 2*size)
       .attr("y", 6.5*size)
       .text("300k$");

labelsG.append("text")
       .attr("x", 30 + 3*size)
       .attr("y", 7.5*size)
       .text("500k$");

labelsG.selectAll("text")
       .attr("font-size", "14px")
       .attr("fill", "white")
       .attr("text-anchor", "middle");

var blocksG = svg.append("g");

var blockRect = blocksG.selectAll("rect")
                   .data(blocks)
                   .enter()
                   .append("rect")
                   .on("mousedown", mousedown);

    blockRect.attr("x", function(d) {
              if (d >= layer2 && d < layer3) {
                return (d + 2 - layer2)*size;
              }
              else if (d >= layer3 && d < layer4) {
                return (d + 3 - layer3)*size;
              }
              else if (d >= layer4) {
                return (d + 4 - layer4)*size;
              }
              else {
                return (d+1)*size;
              }
              })
              .attr("y", function(d) {
              if (d >= layer2 && d < layer3) {
                return 5*size;
              }
              else if (d >= layer3 && d < layer4) {
                return 6*size;
              }
              else if (d >= layer4) {
                return 7*size;
              }
              else {
                return 4*size;
              }
              })
              .attr("height", size)
              .attr("width", size)
              .attr("stroke", "black")
              .attr("stroke-width", 1)
              .attr("class", function (d) {
                        var typeinitial;
                        if (d === 0 || d === 6 || d == 9 || d == 11 || d == 16 || d == 17) {
                           typeinitial = "typed";
                        }
                        else if (d === 1 || d === 4 || d == 7 || d == 22 || d == 24) {
                           typeinitial = "typeb";
                        }
                        else if (d === 18 || d === 21 || d == 26 || d == 27) {
                           typeinitial = "typee";
                        }
                        else {
                           typeinitial = "typea";
                        }
                        console.log(typeinitial)
                        return typeinitial;
                    });

var solutionG = svg.append("g");

var solutionRect = solutionG.selectAll("rect")
                  .on("mousedown", removeSol);

// sets type of clicked rectangle
function mousedown() {
  // Remove rectangles from previous solution
  solutionG.selectAll("rect")
           .remove();

  d3.select(this)
    .attr("class", type);
}

// Change the type
function buttonpress() {
  type = d3.select(this).attr("class")
  console.log(type)
}

function removeSol() {
  solutionG.selectAll("rect")
           .remove();
}

// Compute
function compute() {
  //cost = [100, 100, 100, 100, 100, 100, 100, 100, 1000, 200, 200, 200, 200, 1000, 1000, 1000, 300, 1000];
  //value = [200, 0, 0, 0, 0, 0, 300, 0, 0, 500, 0, 200, 0, 0, 0, 0, 1000, 1200];
  blocksG.selectAll("rect").attr("class", function(d) {
                                      var tempType = d3.select(this).attr("class");
                                      if (tempType === "typea") {
                                        value[d] = 0;
                                      }
                                      if (tempType === "typeb") {
                                        value[d] = 150;
                                      }
                                      if (tempType === "typec") {
                                        value[d] = 250;
                                      }
                                      if (tempType === "typed") {
                                        value[d] = 400;
                                      }
                                      if (tempType === "typee") {
                                        value[d] = 700;
                                      }
                                      return d3.select(this).attr("class");
                                    });

  console.log('cost',cost)
  console.log('value',value)
  console.log('edges',edges)

  d3.json('/openPitMining')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'cost': cost,
                          'value': value,
                          'edges': edges }), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          var solTemp = [];
          profit = solution[solution.length - 1]; // Last element is profit

          console.log('test',solution)

          solution = solution.slice(0,solution.length-1);

          console.log('test',solution)

          for (var i = 0; i < solution.length; i++) {
            if (solution[i] === 1) {
              solTemp.push(i);
            }
          }
          solution = solTemp;
          console.log('solution', solution)
          console.log('profit', profit)

          solutionG.selectAll("rect")
                   .remove();

          var rectSol = solutionG.selectAll("rect")
                                   .data(solution)
                                   .enter()
                                   .append("rect");

          rectSol.attr("x", function(d) {
                      if (d >= layer2 && d < layer3) {
                        return (d + 2 - layer2)*size;
                      }
                      else if (d >= layer3 && d < layer4) {
                        return (d + 3 - layer3)*size;
                      }
                      else if (d >= layer4) {
                        return (d + 4 - layer4)*size;
                      }
                      else {
                        return (d+1)*size;
                      }
                      })
                      .attr("y", function(d) {
                      if (d >= layer2 && d < layer3) {
                        return 5*size;
                      }
                      else if (d >= layer3 && d < layer4) {
                        return 6*size;
                      }
                      else if (d >= layer4) {
                        return 7*size;
                      }
                      else {
                        return 4*size;
                      }
                      })
                      .attr("height", size)
                      .attr("width", size)
                      .attr("fill", "rgb(6,214,255)")
                      .attr("stroke", "rgb(6,214,255)")
                      .attr("stroke-width", 1.8)
                      .style("opacity", 0)
                      .style("stroke-opacity", 0)
                      .transition()
                      .style("opacity", 1)
                      .style("stroke-opacity", 1)
                      .duration(500)
                      .delay(function(i) { return i*100 });

          profit = profit/1000;

          solutionG.selectAll("text").remove();

          solutionG.append("text")
                    .text("Profit: " + String(profit) + " million dollars")
                    .attr("x", width/2)
                    .attr("y", 150)
                    .attr("font-size", "22px")
                    .attr("fill", "white")
                    .attr("text-anchor", "middle");


          solutionRect = solutionG.selectAll("rect")
                  .on("mousedown", removeSol);
        }
   }
}

</script>
